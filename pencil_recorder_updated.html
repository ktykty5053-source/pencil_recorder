<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pencil Recorder (iPad Scroll Lock + Slider Zoom)</title>
  <style>
    :root{
      --bg:#ffffff; --fg:#111; --muted:#666;
      --bd:#e5e7eb; --panel:#fff;
      --shadow:0 10px 30px rgba(0,0,0,.10);
    }

    /* ✅ iPad/Safari 스크롤/바운스/전파 차단 (핵심) */
    html, body{
      height:100%;
      margin:0;
      overflow:hidden;           /* 스크롤바 제거 */
      overscroll-behavior:none;  /* 바운스/스크롤 전파 방지 */
      touch-action:none;         /* 터치/펜 제스처로 스크롤되는 것 방지 */
      background:var(--bg);
      color:var(--fg);
      font-family:-apple-system,system-ui,sans-serif;
    }

    .top{
      position:sticky; top:0; z-index:30;
      background:rgba(255,255,255,.92);
      backdrop-filter:saturate(180%) blur(12px);
      border-bottom:1px solid var(--bd);
      padding:10px 12px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .left,.right{ display:flex; gap:8px; align-items:center; }
    button{
      border:1px solid var(--bd);
      background:var(--panel);
      border-radius:12px;
      padding:10px 12px;
      font:inherit;
      cursor:pointer;
      box-shadow: var(--shadow);
    }
    button.ghost{ box-shadow:none; background:transparent; }
    #status{ font-size:12px; color:var(--muted); }

    .stage{
      position:relative;
      width:100%;
      height:calc(100vh - 58px);
      overflow:hidden;
      background:#fff;
      touch-action:none; /* 캔버스 위에서 제스처 스크롤 차단 */
    }

    canvas{ position:absolute; left:0; top:0; width:100%; height:100%; }
    #ink{ background:#fff; }
    #overlay{ background:transparent; pointer-events:none; }

    /* ===== Modal ===== */
    .modal-backdrop{
      position:fixed; inset:0; z-index:100;
      background:rgba(0,0,0,.35);
      display:none; align-items:center; justify-content:center;
      padding:16px;
    }
    .modal-backdrop.on{ display:flex; }
    .modal{
      width:min(980px, 100%);
      max-height:min(86vh, 900px);
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
      background:var(--panel);
      border:1px solid var(--bd);
      border-radius:18px;
      box-shadow: var(--shadow);
    }
    .modal-header{
      position:sticky; top:0;
      background:rgba(255,255,255,.96);
      backdrop-filter:saturate(180%) blur(10px);
      border-bottom:1px solid var(--bd);
      padding:12px 14px;
      display:flex; justify-content:space-between; align-items:center;
      gap:10px;
    }
    .modal-title{ font-weight:600; }
    .modal-body{ padding:12px 14px 16px; }
    .grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(280px, 1fr));
      gap:12px;
    }
    @media (max-width: 900px){ .grid{ grid-template-columns: 1fr; } }
    .card{
      border:1px solid var(--bd);
      border-radius:16px;
      padding:12px;
      background:#fff;
    }
    .card h3{ margin:0 0 10px; font-size:13px; color:#222; }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin:8px 0; }
    .row label{ font-size:12px; color:var(--muted); display:flex; gap:8px; align-items:center; }
    .row input[type="number"]{ width:110px; padding:8px; border:1px solid var(--bd); border-radius:10px; }
    .row input[type="range"]{ width:240px; }
    .row input[type="checkbox"]{ transform:translateY(0.5px); }
    .row .btnline{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .help{ font-size:12px; color:var(--muted); line-height:1.5; margin-top:8px; }
    .divider{ height:1px; background:var(--bd); margin:10px 0; }
    input[type="file"]{ font-size:12px; }
    code.k{ font-size:12px; background:#f7f7f7; padding:2px 6px; border-radius:8px; border:1px solid #eee; }

    .zoomCtrl{ display:flex; gap:8px; align-items:center; }
    .zoomCtrl .zlabel{ font-size:12px; color:var(--muted); }
    .zoomCtrl input[type="range"]{ width:180px; }
    .zoomCtrl #zoomLabel{ font-size:12px; color:var(--muted); min-width:48px; text-align:right; }

  </style>
</head>
<body>
  <div class="top">
    <div class="left">
      <button id="clear">Clear</button>
      <button id="downloadRaw">Download RAW</button>
      <button id="openMenu">Menu</button>
    </div>
    <div class="right">
      <div class="zoomCtrl" aria-label="Zoom control">
        <span class="zlabel">Zoom</span>
        <input id="zoomRange" type="range" min="25" max="300" step="1" value="100">
        <span id="zoomLabel">100%</span>
        <button id="viewReset" class="ghost" title="Reset zoom">Reset</button>
      </div>
      <div id="status">ready</div>
    </div>
  </div>

  <div class="stage" id="stage">
    <canvas id="ink"></canvas>
    <canvas id="overlay"></canvas>
  </div>

  <div class="modal-backdrop" id="backdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Settings">
      <div class="modal-header">
        <div class="modal-title">설정</div>
        <button id="closeMenu" class="ghost">닫기</button>
      </div>

      <div class="modal-body">
        <div class="grid">
<div class="card">
            <h3>A3 Frame</h3>
            <div class="row">
              <label><input id="lockA3" type="checkbox" checked> Lock A3 frame</label>
              <label><input id="a3Landscape" type="checkbox"> A3 가로</label>
            </div>
            <div class="row">
              <label><input id="showFrame" type="checkbox" checked> Show frame</label>
              <label><input id="clampFrame" type="checkbox" checked> Clamp frame</label>
            </div>
            <div class="divider"></div>
            <div class="row">
              <label>Frame margin(px)</label>
              <input id="frameMargin" type="number" value="140" min="0" step="10">
            </div>
          </div>

          <div class="card">
            <h3>Arm / Workspace</h3>
            <div class="row">
              <label><input id="showWS" type="checkbox" checked> Workspace 표시</label>
              <label><input id="clampWS" type="checkbox" checked> Clamp WS</label>
            </div>
            <div class="row">
              <label><input id="showArm" type="checkbox" checked> Show arm</label>
              <label><input id="saveTheta" type="checkbox" checked> Save θ</label>
            </div>
            <div class="divider"></div>
            <div class="row">
              <label><input id="autoReach" type="checkbox" checked> Auto-fit Reach (항상 전체 커버)</label>
            </div>
            <div class="row">
              <label>Base u</label>
              <input id="baseU" type="number" value="0.50" step="0.01" min="-2" max="2">
            </div>
            <div class="row">
              <label>Base v (v&gt;1이면 프레임 아래 바깥)</label>
              <input id="baseV" type="number" value="1.08" step="0.01" min="-2" max="3">
            </div>
          </div>

          <div class="card">
            <h3>Links / IK</h3>
            <div class="row"><label>l1</label><input id="l1" type="number" value="260" min="10" step="1"></div>
            <div class="row"><label>l2</label><input id="l2" type="number" value="220" min="10" step="1"></div>
            <div class="row"><label>l3</label><input id="l3" type="number" value="180" min="10" step="1"></div>
            <div class="divider"></div>
            <div class="row"><label>IK iters</label><input id="ikIters" type="number" value="14" min="1" step="1"></div>
            <div class="row"><label>λ (댐핑)</label><input id="ikLambda" type="number" value="12" min="0" step="1"></div>
          </div>

          <div class="card">
            <h3>Record (기록)</h3>
            <div class="row">
              <label><input id="penOnly" type="checkbox" checked> Pen only</label>
              <span class="help" style="margin:0">마우스/손가락 입력 차단</span>
            </div>
            <div class="row">
              <label><input id="recSpeedLimit" type="checkbox" checked> Speed limit</label>
              <input id="recMaxSpeed" type="number" value="2500" min="100" step="50">
            </div>
            <div class="row">
              <label><input id="recResample" type="checkbox" checked> Resample</label>
              <input id="recStepPx" type="number" value="2" min="1" step="1">
            </div>
            <div class="row">
              <label><input id="recSmooth" type="checkbox" checked> Smooth α</label>
              <input id="recAlpha" type="range" min="0" max="1" step="0.01" value="0.35">
            </div>
          </div>

          <div class="card">
            <h3>Preprocess (Export 시)</h3>
            <div class="row">
              <label><input id="ppResample" type="checkbox" checked> Resample</label>
              <input id="ppStep" type="number" value="8" min="1" step="1">
            </div>
            <div class="row">
              <label><input id="ppSmooth" type="checkbox" checked> Smooth k</label>
              <input id="ppK" type="number" value="5" min="1" step="2">
            </div>
          </div>

          <div class="card">
            <h3>Export / Import</h3>
            <div class="row">
              <div class="btnline">
                <button id="exportCleanJson">CLEAN JSON</button>
                <button id="exportJsonl">JSONL</button>
                <button id="exportA3Png">A3 PNG</button>
              </div>
            </div>
            <div class="divider"></div>
            <div class="row">
              <label>Import</label>
              <input id="importJson" type="file" accept=".json,application/json">
            </div>
          </div>

        </div>

        <div class="help" style="margin-top:10px">
          iPad에서 길게 그릴 때 스크롤이 잡히는 문제는 <code class="k">html/body overflow:hidden + touchmove preventDefault</code>로 차단되어야 합니다.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ✅ iOS에서 스크롤이 먹는 경우를 강제로 차단(보험)
  document.addEventListener("touchmove", (e) => {
    // ✅ 메인(그리기) 영역에서는 스크롤/바운스 차단, 메뉴(모달) 내부에서는 스크롤 허용
    if (!e.target.closest(".modal")) e.preventDefault();
  }, { passive:false });

  // ===== A3 =====
  const A3_PORTRAIT  = { mmW: 297, mmH: 420, pxW: 3508, pxH: 4961, ratio: 297/420, orientation: "portrait" };
  const A3_LANDSCAPE = { mmW: 420, mmH: 297, pxW: 4961, pxH: 3508, ratio: 420/297, orientation: "landscape" };

  // ===== DOM =====
  const stage = document.getElementById("stage");
  const ink = document.getElementById("ink");
  const ov  = document.getElementById("overlay");
  const ctx = ink.getContext("2d", { desynchronized:true });
  const g   = ov.getContext("2d",  { desynchronized:true });
  const status = document.getElementById("status");

  const ui = {
    openMenu: document.getElementById("openMenu"),
    closeMenu: document.getElementById("closeMenu"),
    backdrop: document.getElementById("backdrop"),

    clear: document.getElementById("clear"),
    downloadRaw: document.getElementById("downloadRaw"),

    zoomRange: document.getElementById("zoomRange"),
    zoomLabel: document.getElementById("zoomLabel"),
    viewReset: document.getElementById("viewReset"),

    penOnly: document.getElementById("penOnly"),

    lockA3: document.getElementById("lockA3"),
    a3Landscape: document.getElementById("a3Landscape"),
    showFrame: document.getElementById("showFrame"),
    clampFrame: document.getElementById("clampFrame"),
    frameMargin: document.getElementById("frameMargin"),

    showWS: document.getElementById("showWS"),
    clampWS: document.getElementById("clampWS"),
    showArm: document.getElementById("showArm"),
    saveTheta: document.getElementById("saveTheta"),
    autoReach: document.getElementById("autoReach"),

    baseU: document.getElementById("baseU"),
    baseV: document.getElementById("baseV"),

    l1: document.getElementById("l1"),
    l2: document.getElementById("l2"),
    l3: document.getElementById("l3"),

    ikIters: document.getElementById("ikIters"),
    ikLambda: document.getElementById("ikLambda"),

    recSpeedLimit: document.getElementById("recSpeedLimit"),
    recMaxSpeed: document.getElementById("recMaxSpeed"),
    recResample: document.getElementById("recResample"),
    recStepPx: document.getElementById("recStepPx"),
    recSmooth: document.getElementById("recSmooth"),
    recAlpha: document.getElementById("recAlpha"),

    ppResample: document.getElementById("ppResample"),
    ppStep: document.getElementById("ppStep"),
    ppSmooth: document.getElementById("ppSmooth"),
    ppK: document.getElementById("ppK"),

    exportCleanJson: document.getElementById("exportCleanJson"),
    exportJsonl: document.getElementById("exportJsonl"),
    exportA3Png: document.getElementById("exportA3Png"),
    importJson: document.getElementById("importJson"),
  };

  // ===== modal =====
  function openModal(){ ui.backdrop.classList.add("on"); ui.backdrop.setAttribute("aria-hidden","false"); }
  function closeModal(){ ui.backdrop.classList.remove("on"); ui.backdrop.setAttribute("aria-hidden","true"); }
  ui.openMenu.onclick = openModal;
  ui.closeMenu.onclick = closeModal;
  ui.backdrop.addEventListener("mousedown", (e)=>{ if (e.target===ui.backdrop) closeModal(); });
  window.addEventListener("keydown",(e)=>{ if (e.key==="Escape") closeModal(); });

  // ===== helpers =====
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const hypot = (x,y)=>Math.hypot(x,y);
  const nowMs = ()=>performance.now();
  function getPressure(e){
    if (typeof e.pressure === "number") return e.pressure;
    if (typeof e.force === "number") return e.force;
    return 0.5;
  }
  function a3Spec(){ return ui.a3Landscape.checked ? A3_LANDSCAPE : A3_PORTRAIT; }
  function linkLengths(){ return [Number(ui.l1.value), Number(ui.l2.value), Number(ui.l3.value)]; }

  // ===== HiDPI canvas =====
  let dpr=1, viewW=0, viewH=0;
  function setCanvasSize(c){
    c.width = Math.floor(viewW*dpr);
    c.height = Math.floor(viewH*dpr);
    c.style.width = viewW+"px";
    c.style.height = viewH+"px";
  }

  // ===== Camera (slider zoom) =====
  const cam = { s:1, x:0, y:0 }; // screen = world*s + pan
  function applyTransform(c){
    c.setTransform(dpr*cam.s, 0, 0, dpr*cam.s, dpr*cam.x, dpr*cam.y);
  }
  function screenToWorld(sx,sy){
    return { x:(sx - cam.x)/cam.s, y:(sy - cam.y)/cam.s };
  }
  function updateZoomLabel(){
    ui.zoomLabel.textContent = `${Math.round(cam.s*100)}%`;
  }

  // ===== frame + base =====
  let drawRect={x:0,y:0,w:0,h:0};
  let baseUV={u:0.50, v:1.08};
  let baseWorld={x:0,y:0}; // world coords

  function computeDrawRect(w,h){
    const margin = Math.max(0, Number(ui.frameMargin.value)||0);
    const innerW = Math.max(1, w - margin*2);
    const innerH = Math.max(1, h - margin*2);
    const offsetX = margin;
    const offsetY = margin;

    if (!ui.lockA3.checked){
      return {x:offsetX,y:offsetY,w:innerW,h:innerH};
    }

    const ratio = a3Spec().ratio;
    let hh = innerH;
    let ww = hh * ratio;
    if (ww > innerW){ ww = innerW; hh = ww / ratio; }

    return { x: offsetX + (innerW-ww)*0.5, y: offsetY + (innerH-hh)*0.5, w: ww, h: hh };
  }

  function updateBase(){
    baseUV.u = Number(ui.baseU.value);
    baseUV.v = Number(ui.baseV.value);

    let bx = drawRect.x + drawRect.w * baseUV.u;
    let by = drawRect.y + drawRect.h * baseUV.v;

    // 화면에서 너무 멀리 나가 팔이 “아예 안 보이는” 상태 방지(월드 기준)
    const margin = 160;
    bx = clamp(bx, -margin, viewW + margin);
    by = clamp(by, -margin, viewH + margin);

    baseUV.u = (bx - drawRect.x) / drawRect.w;
    baseUV.v = (by - drawRect.y) / drawRect.h;
    ui.baseU.value = baseUV.u.toFixed(2);
    ui.baseV.value = baseUV.v.toFixed(2);

    baseWorld.x = bx; baseWorld.y = by;
  }

  function clampToFrame(x,y){
    return {
      x: clamp(x, drawRect.x, drawRect.x + drawRect.w),
      y: clamp(y, drawRect.y, drawRect.y + drawRect.h),
    };
  }
  function toUV(x,y){
    const u=(x-drawRect.x)/drawRect.w;
    const v=(y-drawRect.y)/drawRect.h;
    return { u:clamp(u,0,1), v:clamp(v,0,1) };
  }

  // ===== reach / workspace =====
  function reachRadii(l1,l2,l3){
    const sum=l1+l2+l3;
    const mx=Math.max(l1,l2,l3);
    const inner=Math.max(0, mx - (sum - mx));
    return { rMin: inner, rMax: sum };
  }
  function ensureNoHole(l1,l2,l3){
    let a=l1,b=l2,c=l3;
    const sum=a+b+c;
    const mx=Math.max(a,b,c);
    const others=sum-mx;
    if (mx <= others) return [a,b,c];

    const need = mx - others;
    const smallSum = others;
    const scale = (smallSum + need) / Math.max(1e-9, smallSum);
    if (a !== mx) a *= scale;
    if (b !== mx) b *= scale;
    if (c !== mx) c *= scale;
    return [a,b,c];
  }
  function ensureFullCoverage(){
    if (!ui.autoReach.checked) return;

    const corners = [
      {x:drawRect.x, y:drawRect.y},
      {x:drawRect.x+drawRect.w, y:drawRect.y},
      {x:drawRect.x, y:drawRect.y+drawRect.h},
      {x:drawRect.x+drawRect.w, y:drawRect.y+drawRect.h},
    ];
    const dmax = Math.max(...corners.map(p=>hypot(p.x-baseWorld.x, p.y-baseWorld.y)));
    const pad = 10;

    let [l1,l2,l3] = linkLengths();
    [l1,l2,l3] = ensureNoHole(l1,l2,l3);

    const rMax = l1+l2+l3;
    const need = dmax + pad;
    if (rMax < need){
      const scale = need / Math.max(1e-9, rMax);
      l1 *= scale; l2 *= scale; l3 *= scale;
    }

    ui.l1.value = String(Math.round(l1));
    ui.l2.value = String(Math.round(l2));
    ui.l3.value = String(Math.round(l3));
  }

  function clampToWorkspace(x,y){
    const [l1,l2,l3]=linkLengths();
    const {rMin,rMax}=reachRadii(l1,l2,l3);
    const dx=x-baseWorld.x, dy=y-baseWorld.y;
    const r=hypot(dx,dy);
    if (r===0){
      if (rMin>0) return {x:baseWorld.x+rMin, y:baseWorld.y};
      return {x,y};
    }
    let rr=r;
    if (rr>rMax) rr=rMax;
    if (rr<rMin) rr=rMin;
    const s=rr/r;
    return { x:baseWorld.x+dx*s, y:baseWorld.y+dy*s };
  }

  // ===== IK =====
  function fk(theta,l1,l2,l3){
    const [t1,t2,t3]=theta;
    const a1=t1, a2=t1+t2, a3=t1+t2+t3;
    const x1=baseWorld.x + l1*Math.cos(a1);
    const y1=baseWorld.y + l1*Math.sin(a1);
    const x2=x1 + l2*Math.cos(a2);
    const y2=y1 + l2*Math.sin(a2);
    const x3=x2 + l3*Math.cos(a3);
    const y3=y2 + l3*Math.sin(a3);
    return {x1,y1,x2,y2,x3,y3};
  }
  function jacobian(theta,l1,l2,l3){
    const [t1,t2,t3]=theta;
    const a1=t1, a2=t1+t2, a3=t1+t2+t3;
    const s1=Math.sin(a1), c1=Math.cos(a1);
    const s2=Math.sin(a2), c2=Math.cos(a2);
    const s3=Math.sin(a3), c3=Math.cos(a3);

    const dxd1 = -l1*s1 - l2*s2 - l3*s3;
    const dxd2 =          - l2*s2 - l3*s3;
    const dxd3 =                    - l3*s3;

    const dyd1 =  l1*c1 + l2*c2 + l3*c3;
    const dyd2 =           l2*c2 + l3*c3;
    const dyd3 =                     l3*c3;

    return [[dxd1,dxd2,dxd3],[dyd1,dyd2,dyd3]];
  }

  let lastAngles=[0,0,0];

  function ikSolve(targetX,targetY,theta0){
    const [l1,l2,l3]=linkLengths();
    const iters=clamp(Number(ui.ikIters.value)||14,1,400);
    const lambda=Math.max(0, Number(ui.ikLambda.value)||0);

    let th=theta0.slice();
    for (let k=0;k<iters;k++){
      const f=fk(th,l1,l2,l3);
      const ex=targetX-f.x3, ey=targetY-f.y3;
      if (Math.hypot(ex,ey) < 0.5) break;

      const J=jacobian(th,l1,l2,l3);
      const a11 = J[0][0]*J[0][0] + J[0][1]*J[0][1] + J[0][2]*J[0][2] + lambda*lambda;
      const a12 = J[0][0]*J[1][0] + J[0][1]*J[1][1] + J[0][2]*J[1][2];
      const a21 = a12;
      const a22 = J[1][0]*J[1][0] + J[1][1]*J[1][1] + J[1][2]*J[1][2] + lambda*lambda;

      const det = a11*a22 - a12*a21;
      if (Math.abs(det) < 1e-9) break;

      const inv11=a22/det, inv12=-a12/det;
      const inv21=-a21/det, inv22=a11/det;

      const vx=inv11*ex + inv12*ey;
      const vy=inv21*ex + inv22*ey;

      const dq1 = J[0][0]*vx + J[1][0]*vy;
      const dq2 = J[0][1]*vx + J[1][1]*vy;
      const dq3 = J[0][2]*vx + J[1][2]*vy;

      const step=0.35;
      th[0]+=step*dq1; th[1]+=step*dq2; th[2]+=step*dq3;
    }
    return th;
  }

  function aimArmToCenter(){
    const cx=drawRect.x + drawRect.w*0.5;
    const cy=drawRect.y + drawRect.h*0.5;
    lastAngles = ikSolve(cx,cy,lastAngles);
  }

  // ===== Zoom behavior (keep frame centered) =====
  function setZoom(scale){
    const s = clamp(scale, 0.25, 3.0);
    // anchor: frame center in world
    const ax = drawRect.x + drawRect.w*0.5;
    const ay = drawRect.y + drawRect.h*0.5;
    // anchor should appear at screen center
    const sx = viewW * 0.5;
    const sy = viewH * 0.5;

    cam.s = s;
    cam.x = sx - ax * cam.s;
    cam.y = sy - ay * cam.s;
    updateZoomLabel();

    redrawAllInk();
    redrawOverlay();
  }

  ui.viewReset.onclick = ()=>{
    ui.zoomRange.value = "100";
    setZoom(1);
  };
  ui.zoomRange.addEventListener("input", ()=>{
    const v = Number(ui.zoomRange.value)/100;
    setZoom(v);
  });

  // ===== draw =====
  let strokes=[]; // [{points:[{x,y,u,v,t,p,theta?}]}]
  let current=null;
  let lastKept=null;
  let lastRaw=null;

  function redrawAllInk(){
    // clear in device space
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,viewW,viewH);

    applyTransform(ctx);

    ctx.save();
    ctx.lineWidth=2.5;
    ctx.strokeStyle="#000";
    ctx.lineCap="round";
    ctx.lineJoin="round";

    for (const s of strokes){
      const pts=s.points||[];
      if (pts.length===1){
        ctx.beginPath();
        ctx.arc(pts[0].x, pts[0].y, 1.2, 0, Math.PI*2);
        ctx.fillStyle="#000";
        ctx.fill();
      }
      for (let i=1;i<pts.length;i++){
        ctx.beginPath();
        ctx.moveTo(pts[i-1].x,pts[i-1].y);
        ctx.lineTo(pts[i].x,pts[i].y);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function redrawOverlay(){
    g.setTransform(dpr,0,0,dpr,0,0);
    g.clearRect(0,0,viewW,viewH);

    applyTransform(g);

    if (ui.showFrame.checked){
      g.save();
      g.fillStyle="rgba(240,240,240,0.92)";

      // outside frame (월드 기준으로 큰 면적)
      const big = 20000;
      g.fillRect(-big,-big, big + drawRect.x, big*2);
      g.fillRect(drawRect.x+drawRect.w, -big, big, big*2);
      g.fillRect(drawRect.x, -big, drawRect.w, big + drawRect.y);
      g.fillRect(drawRect.x, drawRect.y+drawRect.h, drawRect.w, big);

      g.lineWidth=1.25;
      g.strokeStyle="#bbb";
      g.strokeRect(drawRect.x,drawRect.y,drawRect.w,drawRect.h);
      g.restore();
    }

    if (ui.showWS.checked){
      const [l1,l2,l3]=linkLengths();
      const {rMin,rMax}=reachRadii(l1,l2,l3);
      g.save();
      g.lineWidth=1;
      g.strokeStyle="#b0b0b0";
      g.beginPath(); g.arc(baseWorld.x,baseWorld.y,rMax,0,Math.PI*2); g.stroke();
      if (rMin > 0.5){ g.beginPath(); g.arc(baseWorld.x,baseWorld.y,rMin,0,Math.PI*2); g.stroke(); }
      g.fillStyle="#9a9a9a";
      g.beginPath(); g.arc(baseWorld.x,baseWorld.y,3.2,0,Math.PI*2); g.fill();
      g.restore();
    }

    if (ui.showArm.checked){
      const [l1,l2,l3]=linkLengths();
      const f=fk(lastAngles,l1,l2,l3);

      g.save();
      g.lineWidth=2.5;
      g.strokeStyle="#5f5f5f";
      g.beginPath();
      g.moveTo(baseWorld.x,baseWorld.y);
      g.lineTo(f.x1,f.y1);
      g.lineTo(f.x2,f.y2);
      g.lineTo(f.x3,f.y3);
      g.stroke();

      g.fillStyle="#5f5f5f";
      for (const [x,y] of [[baseWorld.x,baseWorld.y],[f.x1,f.y1],[f.x2,f.y2],[f.x3,f.y3]]){
        g.beginPath(); g.arc(x,y,3.2,0,Math.PI*2); g.fill();
      }
      g.restore();
    }
  }

  // ===== resize/reflow =====
  function reflowAll(){
    drawRect = computeDrawRect(viewW, viewH);
    updateBase();
    ensureFullCoverage();
    aimArmToCenter();
    // zoom 유지: 슬라이더 값 기반으로 재적용(프레임 중심 고정)
    setZoom(Number(ui.zoomRange.value)/100);
  }

  function resize(){
    dpr = window.devicePixelRatio || 1;
    viewW = stage.clientWidth;
    viewH = stage.clientHeight;
    setCanvasSize(ink);
    setCanvasSize(ov);
    reflowAll();
  }
  window.addEventListener("resize", resize);

  // ===== record pipeline =====
  const ema=(prev,next,a)=> prev + a*(next-prev);
  function shouldKeepPoint(prev,next){
    if (!prev) return true;
    if (!ui.recResample.checked) return true;
    const step=Math.max(1, Number(ui.recStepPx.value)||2);
    const dx=next.x-prev.x, dy=next.y-prev.y;
    return (dx*dx+dy*dy) >= step*step;
  }

  function processSample(sample){
    let {x,y,t,p}=sample;

    if (ui.clampFrame.checked){
      const c=clampToFrame(x,y); x=c.x; y=c.y;
    }
    if (ui.clampWS.checked){
      const c=clampToWorkspace(x,y); x=c.x; y=c.y;
    }

    if (ui.recSmooth.checked && lastKept){
      const a=Number(ui.recAlpha.value);
      x=ema(lastKept.x,x,a);
      y=ema(lastKept.y,y,a);
      p=ema(lastKept.p ?? p, p, a);
    }

    const uv=toUV(x,y);
    const pt={ x,y,u:uv.u,v:uv.v,t,p };

    // ✅ 팔은 항상 움직임(표시용)
    const th = ikSolve(x,y,lastAngles);
    lastAngles = th;

    // ✅ 저장은 Save θ 켜졌을 때만
    if (ui.saveTheta.checked) pt.theta = th.slice();

    if (!shouldKeepPoint(lastKept,pt)) return;

    current.points.push(pt);

    // incremental draw
    applyTransform(ctx);
    ctx.lineWidth=2.5;
    ctx.strokeStyle="#000";
    ctx.lineCap="round";
    ctx.lineJoin="round";

    if (!lastKept){
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, 1.2, 0, Math.PI*2);
      ctx.fillStyle="#000";
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.moveTo(lastKept.x,lastKept.y);
      ctx.lineTo(pt.x,pt.y);
      ctx.stroke();
    }

    lastKept=pt;
    redrawOverlay();
  }

  function addSampleFromEvent(e){
    const rect=stage.getBoundingClientRect();
    const sx=e.clientX-rect.left;
    const sy=e.clientY-rect.top;
    const w=screenToWorld(sx,sy);

    const p=getPressure(e);
    const t=nowMs();

    if (ui.recSpeedLimit.checked && lastRaw){
      const dt=Math.max(0.001,(t-lastRaw.t)/1000);
      const vmax=Math.max(50, Number(ui.recMaxSpeed.value)||2500);
      const maxDist=vmax*dt;
      const dx=w.x-lastRaw.x, dy=w.y-lastRaw.y;
      const dist=Math.hypot(dx,dy);

      if (dist>maxDist){
        const steps=Math.ceil(dist/maxDist);
        for (let i=1;i<=steps;i++){
          const u=i/steps;
          processSample({
            x:lastRaw.x+dx*u,
            y:lastRaw.y+dy*u,
            t:lastRaw.t+(t-lastRaw.t)*u,
            p:lastRaw.p+(p-lastRaw.p)*u
          });
        }
        lastRaw={x:w.x,y:w.y,t,p};
        return;
      }
    }

    processSample({x:w.x,y:w.y,t,p});
    lastRaw={x:w.x,y:w.y,t,p};
  }

  function startStroke(e){
    if (ui.penOnly.checked && e.pointerType && e.pointerType!=="pen") return;

    current={points:[]};
    strokes.push(current);
    lastKept=null;
    lastRaw=null;

    addSampleFromEvent(e);
    status.textContent = `strokes: ${strokes.length}`;
  }
  function moveStroke(e){
    if (!current) return;
    if (ui.penOnly.checked && e.pointerType && e.pointerType!=="pen") return;
    addSampleFromEvent(e);
  }
  function endStroke(){
    current=null; lastKept=null; lastRaw=null;
    status.textContent = `strokes: ${strokes.length}`;
  }

  stage.addEventListener("pointerdown",(e)=>{
    e.preventDefault();
    stage.setPointerCapture(e.pointerId);
    startStroke(e);
  },{passive:false});
  stage.addEventListener("pointermove",(e)=>{ e.preventDefault(); moveStroke(e); },{passive:false});
  stage.addEventListener("pointerup",(e)=>{ e.preventDefault(); endStroke(); },{passive:false});
  stage.addEventListener("pointercancel",(e)=>{ e.preventDefault(); endStroke(); },{passive:false});

  // ===== export / preprocess (이전과 동일) =====
  function buildMeta(){
    const [l1,l2,l3]=linkLengths();
    const {rMin,rMax}=reachRadii(l1,l2,l3);
    const spec=a3Spec();
    return {
      createdAt:new Date().toISOString(),
      a3:{ orientation:spec.orientation, mm:{w:spec.mmW,h:spec.mmH}, dpiTarget:300, pxTarget:{w:spec.pxW,h:spec.pxH} },
      drawRectWorld:drawRect,
      view:{ zoom:cam.s },
      frameMarginPx:Number(ui.frameMargin.value)||0,
      arm:{ linksPx:{l1,l2,l3}, workspace:{rMin,rMax}, baseUV:{...baseUV}, baseWorld:{...baseWorld} },
      settings:{ penOnly:ui.penOnly.checked, saveTheta:ui.saveTheta.checked, autoReach:ui.autoReach.checked }
    };
  }

  function downloadBlob(blob, filename){
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a");
    a.href=url; a.download=filename; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }
  function downloadJSON(obj, filename){
    downloadBlob(new Blob([JSON.stringify(obj)],{type:"application/json"}), filename);
  }

  ui.downloadRaw.onclick = ()=> downloadJSON({meta:buildMeta(),strokes}, "strokes.json");

  ui.clear.onclick = ()=>{
    strokes=[]; current=null; lastKept=null; lastRaw=null;
    lastAngles=[0,0,0];
    redrawAllInk();
    redrawOverlay();
    status.textContent="cleared";
  };

  function uvDist(a,b){ return Math.hypot(a.u-b.u, a.v-b.v); }
  function movingAverage(points,k){
    if (k<=1 || points.length<k) return points;
    const half=Math.floor(k/2);
    const out=[];
    for (let i=0;i<points.length;i++){
      const lo=Math.max(0,i-half), hi=Math.min(points.length,i+half+1);
      let su=0,sv=0,sp=0,st=0,n=0;
      let sth=null;
      for (let j=lo;j<hi;j++){
        const p=points[j];
        su+=p.u; sv+=p.v; sp+=(p.p??0.5); st+=(p.t??0);
        if (Array.isArray(p.theta)){
          if (!sth) sth=[0,0,0];
          sth[0]+=p.theta[0]; sth[1]+=p.theta[1]; sth[2]+=p.theta[2];
        }
        n++;
      }
      const base={...points[i]};
      base.u=su/n; base.v=sv/n; base.p=sp/n; base.t=st/n;
      if (sth) base.theta=[sth[0]/n, sth[1]/n, sth[2]/n];
      out.push(base);
    }
    return out;
  }

  function resampleByStep(points, stepA3Px){
    if (points.length<2) return points;
    const spec=a3Spec();
    const stepUV = stepA3Px / Math.max(spec.pxW, spec.pxH);
    const kept=[points[0]];
    let acc=0;
    for (let i=1;i<points.length;i++){
      const a=kept[kept.length-1];
      const b=points[i];
      const d=uvDist(a,b);
      if (d<1e-12) continue;
      if (d+acc<stepUV){ acc+=d; continue; }
      const need=stepUV-acc;
      const tt=need/d;

      const u=a.u+(b.u-a.u)*tt;
      const v=a.v+(b.v-a.v)*tt;
      const p=(a.p??0.5)+((b.p??0.5)-(a.p??0.5))*tt;
      const t=(a.t??0)+((b.t??0)-(a.t??0))*tt;

      const np={...b,u,v,p,t};
      if (Array.isArray(a.theta) && Array.isArray(b.theta)){
        np.theta=[
          a.theta[0]+(b.theta[0]-a.theta[0])*tt,
          a.theta[1]+(b.theta[1]-a.theta[1])*tt,
          a.theta[2]+(b.theta[2]-a.theta[2])*tt
        ];
      }
      kept.push(np);
      acc=0;
    }
    return kept;
  }

  function preprocessCurrent(){
    const step=Math.max(1, Number(ui.ppStep.value)||8);
    const k=Math.max(1, Number(ui.ppK.value)||1);

    const cleaned=[];
    for (const s of strokes){
      let pts=(s.points||[]).map(p=>({ ...p }));
      for (const p of pts){
        p.u=clamp(p.u,0,1); p.v=clamp(p.v,0,1);
        if (typeof p.p!=="number") p.p=0.5;
      }
      if (ui.ppSmooth.checked && k>1) pts=movingAverage(pts,k);
      if (ui.ppResample.checked) pts=resampleByStep(pts,step);
      cleaned.push({ points: pts });
    }
    return { meta: buildMeta(), strokes: cleaned };
  }

  ui.exportCleanJson.onclick = ()=> downloadJSON(preprocessCurrent(), "strokes_clean.json");

  ui.exportJsonl.onclick = ()=>{
    const cleaned=preprocessCurrent();
    const S=cleaned.strokes||[];
    const lines=[];
    for (let si=0; si<S.length; si++){
      const pts=S[si].points||[];
      if (pts.length<2) continue;
      for (let i=0;i<pts.length-1;i++){
        const a=pts[i], b=pts[i+1];
        const obs={u:a.u,v:a.v,p:a.p};
        if (Array.isArray(a.theta)) obs.theta=a.theta;
        const act={du:(b.u-a.u), dv:(b.v-a.v), pen:1};
        lines.push(JSON.stringify({obs,act}));
      }
      if (si<S.length-1){
        const last=pts[pts.length-1];
        const nextPts=S[si+1].points||[];
        if (nextPts.length>0){
          const ns=nextPts[0];
          const obs={u:last.u,v:last.v,p:last.p};
          if (Array.isArray(last.theta)) obs.theta=last.theta;
          const act={du:(ns.u-last.u), dv:(ns.v-last.v), pen:0};
          lines.push(JSON.stringify({obs,act}));
        }
      }
    }
    downloadBlob(new Blob([lines.join("\n")],{type:"text/plain"}), "sequence.jsonl");
  };

  function uvToA3Px(u,v){
    const spec=a3Spec();
    return { x:Math.round(u*(spec.pxW-1)), y:Math.round(v*(spec.pxH-1)) };
  }
  ui.exportA3Png.onclick = ()=>{
    const cleaned=preprocessCurrent();
    const spec=a3Spec();
    const off=document.createElement("canvas");
    off.width=spec.pxW; off.height=spec.pxH;
    const h=off.getContext("2d");
    h.fillStyle="#fff"; h.fillRect(0,0,spec.pxW,spec.pxH);
    h.lineCap="round"; h.lineJoin="round"; h.strokeStyle="#000"; h.lineWidth=3;

    for (const s of (cleaned.strokes||[])){
      const pts=s.points||[];
      if (pts.length<2) continue;
      h.beginPath();
      const p0=uvToA3Px(pts[0].u,pts[0].v);
      h.moveTo(p0.x,p0.y);
      for (let i=1;i<pts.length;i++){
        const pi=uvToA3Px(pts[i].u,pts[i].v);
        h.lineTo(pi.x,pi.y);
      }
      h.stroke();
    }
    off.toBlob((blob)=>{
      if (!blob) return;
      downloadBlob(blob, `render_A3_${spec.orientation}_${spec.pxW}x${spec.pxH}.png`);
    }, "image/png");
  };

  ui.importJson.addEventListener("change", async (e)=>{
    const file=e.target.files && e.target.files[0];
    if (!file) return;
    const text=await file.text();
    let data;
    try{ data=JSON.parse(text); }
    catch{ status.textContent="Import 실패(JSON 파싱)"; ui.importJson.value=""; return; }

    const imported=[];
    for (const s of (data.strokes||[])){
      const pts=(s.points||[]).map(p=>{
        let u=(typeof p.u==="number")?p.u:0;
        let v=(typeof p.v==="number")?p.v:0;
        u=clamp(u,0,1); v=clamp(v,0,1);
        const x=drawRect.x + u*drawRect.w;
        const y=drawRect.y + v*drawRect.h;
        const out={ x,y,u,v,t:p.t??0,p:p.p??0.5 };
        if (Array.isArray(p.theta)) out.theta=p.theta.slice();
        return out;
      });
      imported.push({points:pts});
    }
    strokes=imported;
    current=null; lastKept=null; lastRaw=null;

    lastAngles=[0,0,0];
    for (let i=strokes.length-1;i>=0;i--){
      const pts=strokes[i].points||[];
      for (let j=pts.length-1;j>=0;j--){
        if (Array.isArray(pts[j].theta)){ lastAngles=pts[j].theta.slice(); i=-1; break; }
      }
    }

    redrawAllInk();
    redrawOverlay();
    status.textContent=`Imported strokes: ${strokes.length}`;
    ui.importJson.value="";
  });

  // ===== reactive =====
  const reflowIds=[
    "lockA3","a3Landscape","showFrame","clampFrame","frameMargin",
    "showWS","clampWS","showArm","saveTheta","autoReach",
    "baseU","baseV","l1","l2","l3","ikIters","ikLambda"
  ];
  reflowIds.forEach(id=>{
    document.getElementById(id).addEventListener("change", ()=>{
      reflowAll();
      status.textContent="updated";
    });
  });

  // init
  updateZoomLabel();
  resize();
})();
</script>
</body>
</html>
